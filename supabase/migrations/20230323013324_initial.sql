alter table "auth"."users" add column if not exists "deleted_at" timestamp with time zone;

alter table "auth"."users" alter column "phone" set data type text using "phone"::text;

alter table "auth"."users" alter column "phone_change" set data type text using "phone_change"::text;


create table "public"."attempts" (
    "uid" uuid not null,
    "pid" bigint not null,
    "start_time" timestamp with time zone not null default now(),
    "jsonb" jsonb not null,
    "has_cheated" boolean default false
);


alter table "public"."attempts" enable row level security;

create table "public"."puzzles" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "live_date" date not null,
    "difficulty" text not null default 'daily'::text,
    "puzzle" jsonb not null,
    "solution" jsonb not null,
    "theme" text
);


alter table "public"."puzzles" enable row level security;

create table "public"."solves" (
    "id" bigint generated by default as identity not null,
    "uid" uuid not null,
    "pid" bigint not null,
    "start_time" timestamp with time zone not null,
    "end_time" timestamp with time zone not null,
    "did_cheat" boolean not null
);


alter table "public"."solves" enable row level security;

CREATE UNIQUE INDEX attempts_pkey ON public.attempts USING btree (uid, pid);

CREATE UNIQUE INDEX puzzles_id_key ON public.puzzles USING btree (id);

CREATE UNIQUE INDEX puzzles_pkey ON public.puzzles USING btree (id);

CREATE UNIQUE INDEX solves_pkey ON public.solves USING btree (id);

alter table "public"."attempts" add constraint "attempts_pkey" PRIMARY KEY using index "attempts_pkey";

alter table "public"."puzzles" add constraint "puzzles_pkey" PRIMARY KEY using index "puzzles_pkey";

alter table "public"."solves" add constraint "solves_pkey" PRIMARY KEY using index "solves_pkey";

alter table "public"."attempts" add constraint "attempts_pid_fkey" FOREIGN KEY (pid) REFERENCES puzzles(id) not valid;

alter table "public"."attempts" validate constraint "attempts_pid_fkey";

alter table "public"."attempts" add constraint "attempts_uid_fkey" FOREIGN KEY (uid) REFERENCES auth.users(id) not valid;

alter table "public"."attempts" validate constraint "attempts_uid_fkey";

alter table "public"."puzzles" add constraint "puzzles_id_key" UNIQUE using index "puzzles_id_key";

alter table "public"."solves" add constraint "solves_pid_fkey" FOREIGN KEY (pid) REFERENCES puzzles(id) not valid;

alter table "public"."solves" validate constraint "solves_pid_fkey";

alter table "public"."solves" add constraint "solves_uid_fkey" FOREIGN KEY (uid) REFERENCES auth.users(id) not valid;

alter table "public"."solves" validate constraint "solves_uid_fkey";

create policy "Disable reads"
on "public"."attempts"
as permissive
for select
to public
using (false);


create policy "Enable read access for all users"
on "public"."attempts"
as permissive
for select
to public
using (true);


create policy "Disable reads"
on "public"."puzzles"
as permissive
for select
to public
using (false);


create policy "Disable reads"
on "public"."solves"
as permissive
for select
to public
using (false);



alter table "storage"."buckets" add column if not exists "allowed_mime_types" text[];

alter table "storage"."buckets" add column if not exists "avif_autodetection" boolean default false;

alter table "storage"."buckets" add column if not exists "file_size_limit" bigint;

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO "storage"."objects" ("bucket_id", "name", "owner", "metadata") VALUES (bucketid, name, owner, metadata);
  -- hack to rollback the successful insert
  RAISE sqlstate 'PT200' using
  message = 'ROLLBACK',
  detail = 'rollback successful insert';
END
$function$
;


